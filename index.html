<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DIGIgridChase</title>
<style>
html,body { margin:0; padding:0; height:100%; background:#0b0b0d; font-family:Inter,system-ui,Arial; display:flex; flex-direction:column; }
#game { flex:1; display:block; background: radial-gradient(ellipse at center, #071017 0%, #000 60%); cursor:none; }
#bottomUI { display:flex; flex-direction:column; align-items:center; padding:6px; background:#111; }
#playerName { color:red; font-weight:bold; font-size:18px; margin-bottom:4px; }
#spotifyEmbed { width:100%; max-width:800px; height:80px; border:none; }
#scoreboard { position:absolute; right:12px; top:12px; z-index:10; background:rgba(0,0,0,0.25); padding:10px; border-radius:8px; font-size:13px; }
#scoreboard h3 { margin:0 0 6px 0; font-size:14px; }
#scoreboard ul { margin:0; padding:0 6px; list-style:none; max-height:200px; overflow:auto; }
#fps { position:absolute; left:12px; bottom:12px; background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:6px; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="bottomUI">
  <div id="playerName">YOU</div>
  <iframe id="spotifyEmbed" src="https://open.spotify.com/embed/album/47pjW3XDPW99NShtkeewxl" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
</div>

<div id="scoreboard">
  <h3>Top Entities</h3>
  <ul id="scores"></ul>
</div>

<div id="fps">FPS: <span id="fpsNum">0</span></div>

<script>
/* DIGIgridChase - Responsive single-file demo */

// SETTINGS
let MAP_SIZE = 4000; // will grow each round
const PLAYER_SPEED = 220, PLAYER_RADIUS = 8, TRAIL_MIN_DIST = 4, BOT_SPEED=160, TRAIL_WIDTH=6, MAX_TRAIL_SEGMENTS=100000, COLLISION_DISTANCE=8, TICK_RATE=60;
let level = 1, botRoundCount = 1; // level & bots per round

// GLOBALS
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
let W=canvas.width=window.innerWidth, H=canvas.height=window.innerHeight*0.7; // 70% for game
let lastTs = performance.now(), paused=false;
window.addEventListener('resize',()=>{ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight*0.7; });

const fpsNum=document.getElementById('fpsNum'), scoresEl=document.getElementById('scores');
const playerNameEl = document.getElementById('playerName');

// INPUT
let mouseX=W/2, mouseY=H/2, mouseDown=false;
addEventListener('mousemove',e=>{mouseX=e.clientX; mouseY=e.clientY;});
addEventListener('mousedown',()=>mouseDown=true);
addEventListener('mouseup',()=>mouseDown=false);
const keys={};
addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// UTILS
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }
function rand(min,max){ return Math.random()*(max-min)+min; }

// Spatial hash for trail collisions
class SpatialHash {
  constructor(cellSize=100){ this.cellSize=cellSize; this.map=new Map(); }
  insertSegment(x1,y1,x2,y2,data){ 
    const minx=Math.min(x1,x2), maxx=Math.max(x1,x2), miny=Math.min(y1,y2), maxy=Math.max(y1,y2);
    for(let xi=Math.floor(minx/this.cellSize); xi<=Math.floor(maxx/this.cellSize); xi++)
      for(let yi=Math.floor(miny/this.cellSize); yi<=Math.floor(maxy/this.cellSize); yi++){
        const key=xi+','+yi;
        if(!this.map.has(key)) this.map.set(key,[]);
        this.map.get(key).push(data);
      }
  }
  queryRadius(x,y,r){ const out=new Set(); const minx=Math.floor((x-r)/this.cellSize), maxx=Math.floor((x+r)/this.cellSize), miny=Math.floor((y-r)/this.cellSize), maxy=Math.floor((y+r)/this.cellSize);
    for(let xi=minx; xi<=maxx; xi++) for(let yi=miny; yi<=maxy; yi++){ const arr=this.map.get(xi+','+yi); if(arr) arr.forEach(it=>out.add(it)); }
    return Array.from(out);
  }
  clear(){ this.map.clear(); }
}

const trails=[], trailHash = new SpatialHash(120);

// ENTITY CLASS
let entities={}, entityIdCounter=1;
class Entity{
  constructor(opts){
    this.id=(entityIdCounter++).toString();
    this.name=opts.name||'bot';
    this.x=opts.x||rand(MAP_SIZE*0.1,MAP_SIZE*0.9);
    this.y=opts.y||rand(MAP_SIZE*0.1,MAP_SIZE*0.9);
    this.dir=opts.dir||rand(0,Math.PI*2);
    this.speed=opts.speed||BOT_SPEED;
    this.radius=opts.radius||PLAYER_RADIUS;
    this.color=opts.color||this.randomColor();
    this.alive=true;
    this.lastTrailX=this.x; this.lastTrailY=this.y;
    this.trailPoints=[];
    this.score=0;
    this.isPlayer=!!opts.isPlayer;
    this.boost=false;
    this.spawn();
  }
  randomColor(){ return ['#66ffea','#9ad1ff','#ffd86b','#ff9db4','#c09bff','#8bff8b'][Math.floor(Math.random()*6)]; }
  spawn(){ this.alive=true; this.lastTrailX=this.x; this.lastTrailY=this.y; this.recordTrailPoint(this.x,this.y); this.score=0; }
  recordTrailPoint(nx,ny){
    if(dist(this.lastTrailX,this.lastTrailY,nx,ny)>=TRAIL_MIN_DIST){
      const seg={x1:this.lastTrailX,y1:this.lastTrailY,x2:nx,y2:ny,owner:this.id,w:TRAIL_WIDTH,color:this.color};
      trails.push(seg); trailHash.insertSegment(seg.x1,seg.y1,seg.x2,seg.y2,seg);
      this.lastTrailX=nx; this.lastTrailY=ny;
      if(trails.length>MAX_TRAIL_SEGMENTS){ trails.splice(0,trails.length-MAX_TRAIL_SEGMENTS); rebuildTrailHash(); }
    }
  }
  die(){ this.alive=false; setTimeout(()=>{this.x=rand(MAP_SIZE*0.05,MAP_SIZE*0.95); this.y=rand(MAP_SIZE*0.05,MAP_SIZE*0.95); this.dir=rand(0,Math.PI*2); this.spawn();},900);}
}

function rebuildTrailHash(){ trailHash.clear(); trails.forEach(seg=>trailHash.insertSegment(seg.x1,seg.y1,seg.x2,seg.y2,seg)); }

// PLAYER
const player = new Entity({name:'YOU',isPlayer:true,x:MAP_SIZE/2,y:MAP_SIZE/2,color:'#66ffea'}); entities[player.id]=player;

// SPAWN BOTS ROUND BY ROUND
function spawnBotsForRound(count){ for(let i=0;i<count;i++){ const b = new Entity({name:'bot'+Math.floor(rand(1000,9999)),x:rand(0,MAP_SIZE),y:rand(0,MAP_SIZE),speed:BOT_SPEED}); b.dir=rand(0,Math.PI*2); entities[b.id]=b; }}

// COLLISION
function pointSegmentDistance(px,py,x1,y1,x2,y2){ const l2=(x2-x1)**2+(y2-y1)**2; if(l2===0) return dist(px,py,x1,y1); let t=((px-x1)*(x2-x1)+(py-y1)*(y2-y1))/l2; t=Math.max(0,Math.min(1,t)); return dist(px,py,x1+t*(x2-x1),y1+t*(y2-y1)); }
function checkTrailCollisionFor(entity){
  const near=trailHash.queryRadius(entity.x,entity.y,COLLISION_DISTANCE+8);
  for(const seg of near){ if(seg.owner===entity.id) continue; if(pointSegmentDistance(entity.x,entity.y,seg.x1,seg.y1,seg.x2,seg.y2)<=COLLISION_DISTANCE) return seg; }
  return null;
}

// BOT AI
function botSteer(bot,dt){ if(Math.random()<(dt/1000)*0.8) bot.dir+=rand(-0.7,0.7);
  const margin=150;
  if(bot.x<margin) bot.dir=rand(-0.5,0.5)+0; else if(bot.x>MAP_SIZE-margin) bot.dir=rand(-0.5,0.5)+Math.PI;
  if(bot.y<margin) bot.dir=rand(-0.5,0.5)+Math.PI/2; else if(bot.y>MAP_SIZE-margin) bot.dir=rand(-0.5,0.5)+Math.PI*1.5;
}

// SIMULATE
function simulate(dt){
  // PLAYER
  if(player.alive){
    let worldMouseX=player.x+(mouseX-W/2), worldMouseY=player.y+(mouseY-H/2);
    let inputVX=0,inputVY=0;
    if(keys['arrowup']||keys['w']) inputVY-=1; if(keys['arrowdown']||keys['s']) inputVY+=1;
    if(keys['arrowleft']||keys['a']) inputVX-=1; if(keys['arrowright']||keys['d']) inputVX+=1;
    let dx=worldMouseX-player.x, dy=worldMouseY-player.y, ang=Math.atan2(dy,dx);
    if(Math.abs(inputVX)+Math.abs(inputVY)>0) ang=Math.atan2(inputVY,inputVX);
    const diff=((ang-player.dir+Math.PI)%(2*Math.PI))-Math.PI; player.dir+=diff*clamp(0.12*(dt/16.67),0,1);
    const speed=player.speed*(mouseDown?1.6:1);
    player.vx=Math.cos(player.dir)*speed; player.vy=Math.sin(player.dir)*speed;
    player.x+=player.vx*dt/1000; player.y+=player.vy*dt/1000;
    if(player.x<0)player.x+=MAP_SIZE; if(player.x>=MAP_SIZE)player.x-=MAP_SIZE;
    if(player.y<0)player.y+=MAP_SIZE; if(player.y>=MAP_SIZE)player.y-=MAP_SIZE;
    player.recordTrailPoint(player.x,player.y);
    if(checkTrailCollisionFor(player)) player.die();
  }
  // BOTS
  for(const id in entities){ const e=entities[id]; if(e===player||!e.alive) continue; botSteer(e,dt); e.vx=Math.cos(e.dir)*e.speed; e.vy=Math.sin(e.dir)*e.speed;
    e.x+=e.vx*dt/1000; e.y+=e.vy*dt/1000; if(e.x<0)e.x+=MAP_SIZE;if(e.x>=MAP_SIZE)e.x-=MAP_SIZE; if(e.y<0)e.y+=MAP_SIZE;if(e.y>=MAP_SIZE)e.y-=MAP_SIZE;
    e.recordTrailPoint(e.x,e.y); if(checkTrailCollisionFor(e)) e.die();
  }
}

// CAMERA
function getCamera(){ return {x:player.x, y:player.y}; }

// DRAW
function draw(){
  ctx.save(); ctx.clearRect(0,0,W,H);
  const cam=getCamera();
  ctx.fillStyle='#020509'; ctx.fillRect(0,0,W,H);
  const gridSize=200;
  const startX=Math.floor((cam.x-W/2)/gridSize)*gridSize, endX=Math.floor((cam.x+W/2)/gridSize)*gridSize;
  const startY=Math.floor((cam.y-H/2)/gridSize)*gridSize, endY=Math.floor((cam.y+H/2)/gridSize)*gridSize;
  ctx.strokeStyle='rgba(255,255,255,0.02)'; ctx.lineWidth=1;
  for(let gx=startX;gx<=endX;gx+=gridSize){ const sx=gx-cam.x+W/2; ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,H); ctx.stroke(); }
  for(let gy=startY;gy<=endY;gy+=gridSize){ const sy=gy-cam.y+H/2; ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(W,sy); ctx.stroke(); }
  const visibleSegs=trailHash.queryRadius(cam.x,cam.y,Math.max(W,H)/2+200);
  ctx.lineCap='round'; ctx.lineJoin='round';
  visibleSegs.forEach(seg=>{ const sx1=seg.x1-cam.x+W/2, sy1=seg.y1-cam.y+H/2, sx2=seg.x2-cam.x+W/2, sy2=seg.y2-cam.y+H/2;
    ctx.strokeStyle=seg.color; ctx.lineWidth=seg.w; ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.strokeStyle=seg.color+'44'; ctx.lineWidth=seg.w+6; ctx.stroke(); });
  for(const id in entities){ const e=entities[id]; const sx=e.x-cam.x+W/2, sy=e.y-cam.y+H/2; if(sx<-100||sx>W+100||sy<-100||sy>H+100) continue;
    ctx.beginPath(); ctx.fillStyle=e.color; ctx.arc(sx,sy,e.radius+(e.boost?2:0),0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// SCOREBOARD
function updateScores(){
  const arr=Object.values(entities).sort((a,b)=>b.score-b.score).slice(0,8);
  scoresEl.innerHTML=''; arr.forEach(e=>{ const li=document.createElement('li'); li.textContent=`${e.name} ${e.isPlayer?'(you)':''} â€” ${Math.round(e.score)}`; scoresEl.appendChild(li); });
}

// FPS
let fpsHistory=[];
function trackFPS(dt){ const fps=1000/dt; fpsHistory.push(fps); if(fpsHistory.length>30) fpsHistory.shift(); fpsNum.textContent=Math.round(fpsHistory.reduce((a,b)=>a+b,0)/fpsHistory.length); }

// ROUNDS
function nextRound(){ level++; MAP_SIZE+=1000; botRoundCount++; spawnBotsForRound(botRoundCount); }

setInterval(()=>{ nextRound(); }, 15000); // new round every 15s

// MAIN LOOP
let accumulator=0;
function mainLoop(ts){
  const dt=ts-lastTs; lastTs=ts;
  accumulator+=dt; const step=1000/TICK_RATE;
  while(accumulator>=step){ simulate(step); accumulator-=step; }
  draw(); updateScores(); trackFPS(dt);
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);
rebuildTrailHash();
</script>

</body>
</html>
