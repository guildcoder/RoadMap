<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>DIGIBIKE ROYALE</title>
  <style>
    body { margin:0; background:black; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#000; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const MAP_SIZE = 2500;              
const PLAYER_COUNT = 20;
const TRAIL_POINT_LIMIT = 40;       
const SPEED = 250;
const PLAYER_SIZE = 10;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
document.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
document.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

class Player {
  constructor(x, y, dir, color, isBot=false) {
    this.x = x;
    this.y = y;
    this.dir = dir; // strictly 0, 90, 180, 270
    this.color = color;
    this.isBot = isBot;
    this.trail = [];
    this.alive = true;
    this.speed = SPEED;
    this.turnCooldown = 0; 
  }

  recordTrailPoint(x, y) {
    this.trail.push({x,y});
    if(this.trail.length > TRAIL_POINT_LIMIT) {
      this.trail.shift();
    }
  }

  die() { this.alive = false; }
}

let players = [];
let player = new Player(MAP_SIZE/2, MAP_SIZE/2, 0, "cyan", false);
players.push(player);

// spawn bots
for(let i=0; i<PLAYER_COUNT-1; i++){
  let bot = new Player(
    Math.random()*MAP_SIZE,
    Math.random()*MAP_SIZE,
    [0, Math.PI/2, Math.PI, -Math.PI/2][Math.floor(Math.random()*4)],
    "hsl("+Math.random()*360+",100%,50%)",
    true
  );
  players.push(bot);
}

let spectator = false;
function enableSpectator(){ spectator = true; }

function checkTrailCollisionFor(p) {
  for(let other of players){
    if(!other.alive) continue;
    for(let pt of other.trail){
      if(Math.abs(pt.x - p.x) < PLAYER_SIZE && Math.abs(pt.y - p.y) < PLAYER_SIZE){
        return true;
      }
    }
  }
  return false;
}

// Storm shrinking
let stormSize = MAP_SIZE;
let stormTimer = 10;
let shrinking = false;

function updateStorm(dt){
  stormTimer -= dt/1000;
  if(stormTimer <= 0){
    if(!shrinking){
      shrinking = true;
      stormTimer = 5; 
    } else {
      shrinking = false;
      stormTimer = 10; 
    }
  }
  if(shrinking){
    stormSize -= 50*dt/1000;
    if(stormSize < 200) stormSize = 200;
  }
}

// minimap toggle
let showLargeMap = false;
document.addEventListener("keydown", e => {
  if(e.key === "R" && e.shiftKey) showLargeMap = true;
});
document.addEventListener("keyup", e => {
  if(e.key === "r") showLargeMap = false;
});

// simulation
let last = performance.now();
function loop(now){
  let dt = now - last;
  last = now;
  simulate(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function simulate(dt){
  updateStorm(dt);

  // PLAYER movement (classic tron)
  if(player.alive){
    if(keys['arrowup'] || keys['w']) player.dir = -Math.PI/2;
    else if(keys['arrowdown'] || keys['s']) player.dir = Math.PI/2;
    else if(keys['arrowleft'] || keys['a']) player.dir = Math.PI;
    else if(keys['arrowright'] || keys['d']) player.dir = 0;

    player.x += Math.cos(player.dir) * player.speed * dt/1000;
    player.y += Math.sin(player.dir) * player.speed * dt/1000;

    player.recordTrailPoint(player.x, player.y);

    if(checkTrailCollisionFor(player)) {
      player.die();
      enableSpectator();
    }
  }

  // BOTS
  for(let p of players){
    if(p.isBot && p.alive){
      p.x += Math.cos(p.dir)*p.speed*dt/1000;
      p.y += Math.sin(p.dir)*p.speed*dt/1000;

      p.recordTrailPoint(p.x,p.y);

      p.turnCooldown -= dt/1000;
      if(p.turnCooldown <= 0){
        p.turnCooldown = 1 + Math.random()*2;
        if(Math.random() < 0.5){ 
          let dirs = [0, Math.PI/2, Math.PI, -Math.PI/2];
          let newDir;
          do {
            newDir = dirs[Math.floor(Math.random()*4)];
          } while(newDir === p.dir);
          p.dir = newDir;
        }
      }

      if(checkTrailCollisionFor(p)) p.die();
    }
  }
}

function draw(){
  ctx.fillStyle = "black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // camera
  let cx, cy;
  if(!spectator){ cx = player.x; cy = player.y; }
  else {
    let alive = players.filter(p=>p.alive);
    if(alive.length>0){ cx = alive[0].x; cy = alive[0].y; }
    else { cx = MAP_SIZE/2; cy = MAP_SIZE/2; }
  }

  let scale = 0.3;
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(scale, scale);
  ctx.translate(-cx, -cy);

  // draw grid background
  ctx.strokeStyle = "rgba(0,255,255,0.2)";
  ctx.lineWidth = 2;
  for(let gx=0; gx<MAP_SIZE; gx+=50){
    ctx.beginPath();
    ctx.moveTo(gx,0);
    ctx.lineTo(gx,MAP_SIZE);
    ctx.stroke();
  }
  for(let gy=0; gy<MAP_SIZE; gy+=50){
    ctx.beginPath();
    ctx.moveTo(0,gy);
    ctx.lineTo(MAP_SIZE,gy);
    ctx.stroke();
  }

  // storm: outside = red
  ctx.save();
  ctx.fillStyle = "rgba(255,0,0,0.4)";
  ctx.beginPath();
  ctx.rect(0,0,MAP_SIZE,MAP_SIZE);
  ctx.rect((MAP_SIZE-stormSize)/2, (MAP_SIZE-stormSize)/2, stormSize, stormSize);
  ctx.fill("evenodd");
  ctx.restore();

  // storm border
  ctx.strokeStyle = "purple";
  ctx.lineWidth = 30;
  ctx.strokeRect((MAP_SIZE-stormSize)/2, (MAP_SIZE-stormSize)/2, stormSize, stormSize);

  // trails + players
  for(let p of players){
    ctx.strokeStyle = p.color;
    ctx.beginPath();
    for(let i=0;i<p.trail.length;i++){
      let pt = p.trail[i];
      if(i===0) ctx.moveTo(pt.x, pt.y);
      else ctx.lineTo(pt.x, pt.y);
    }
    ctx.stroke();
    if(p.alive){
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x-PLAYER_SIZE/2, p.y-PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE);
    }
  }

  ctx.restore();

  // HUD
  ctx.fillStyle = "white";
  ctx.font = "16px Arial";
  ctx.textAlign = "right";
  ctx.fillText("Players Alive: "+players.filter(p=>p.alive).length, canvas.width-20, 30);
  ctx.fillText("Storm: "+stormTimer.toFixed(1), canvas.width-20, 50);

  ctx.fillStyle = "red";
  ctx.font = "bold 20px Arial";
  ctx.textAlign = "center";
  ctx.fillText("DIGIBIKE ROYALE", canvas.width/2, canvas.height-20);

  drawMiniMap();
}

function drawMiniMap(){
  let scale = showLargeMap ? 0.4 : 0.15;
  let size = canvas.width*scale;
  ctx.save();
  ctx.translate(canvas.width - size - 10, 10);
  ctx.scale(size/MAP_SIZE, size/MAP_SIZE);

  ctx.strokeStyle = "white";
  ctx.lineWidth = 10;
  ctx.strokeRect((MAP_SIZE-stormSize)/2, (MAP_SIZE-stormSize)/2, stormSize, stormSize);

  for(let p of players){
    if(p.alive){
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 20, 20);
    }
  }
  ctx.restore();
}
</script>
</body>
</html>
