<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DIGIgridChase</title>
<style>
  html,body { margin:0; padding:0; height:100%; background:#0b0b0d; color:#eaeaea; font-family:Inter,Arial,sans-serif; }
  #game { display:block; width:100vw; height:100vh; background: radial-gradient(ellipse at center, #071017 0%, #000 60%); cursor:none; }
  #ui { position:absolute; left:12px; top:12px; z-index:10; background:rgba(0,0,0,0.25); padding:10px 12px; border-radius:8px; backdrop-filter:blur(4px); color:#dfefff; font-size:13px; }
  #scoreboard { position:absolute; right:12px; top:12px; z-index:10; background:rgba(0,0,0,0.25); padding:10px; border-radius:8px; }
  #scoreboard h3 { margin:0 0 6px 0; font-size:14px; }
  #scoreboard ul { margin:0; padding:0 6px; list-style:none; font-size:13px; max-height:220px; overflow:auto; }
  #spotifyBtn { position:absolute; top:12px; right:12px; z-index:20; background:#1db954; color:white; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; font-size:13px; }
  #hint { position:absolute; left:50%; bottom:20px; transform:translateX(-50%); color:#9fb6d8; font-size:13px; opacity:0.9; }
  #fps { position:absolute; left:12px; bottom:12px; background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:6px; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <strong>DIGIgridChase</strong>
  <small>Move: mouse or WASD / arrows • Left click to boost • Respawn on death</small>
</div>

<div id="scoreboard">
  <h3>Top Entities</h3>
  <ul id="scores"></ul>
</div>

<button id="spotifyBtn">▶ Play</button>

<div id="hint">Tip: Only one player? Local bots will appear to chase you!</div>
<div id="fps">FPS: <span id="fpsNum">0</span></div>

<!-- Embed Spotify iframe hidden (we control play via button) -->
<iframe id="spotifyEmbed" src="https://open.spotify.com/embed/album/47pjW3XDPW99NShtkeewxl" width="0" height="0" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" allowfullscreen></iframe>

<script>
/* ==== DIGIgridChase main script ==== */

// CONFIG
const MAP_SIZE = 10000;
const PLAYER_SPEED = 220;
const PLAYER_RADIUS = 8;
const TRAIL_MIN_DIST = 4;
const TRAIL_WIDTH = 6;
const BOT_COUNT_INITIAL = 3;
const BOT_SPEED = 160;
const BOT_SPAWN_INTERVAL = 3000;
const TICK_RATE = 60;
const COLLISION_DISTANCE = 8;
const MAX_TRAIL_SEGMENTS = 100000;

// GLOBALS
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
let lastTs = performance.now();
let paused = false;

window.addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// UI
const fpsNum = document.getElementById('fpsNum');
const scoresEl = document.getElementById('scores');
const spotifyBtn = document.getElementById('spotifyBtn');
const spotifyEmbed = document.getElementById('spotifyEmbed');
let spotifyPlaying = false;
spotifyBtn.onclick = () => {
  spotifyPlaying = !spotifyPlaying;
  if(spotifyPlaying){
    spotifyBtn.textContent = '⏸ Pause';
    spotifyEmbed.contentWindow.postMessage({ method: 'play' }, '*');
  } else {
    spotifyBtn.textContent = '▶ Play';
    spotifyEmbed.contentWindow.postMessage({ method: 'pause' }, '*');
  }
};

// INPUT
let mouseX = W/2, mouseY = H/2, mouseDown=false;
addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });
addEventListener('mousedown', ()=>{ mouseDown=true; });
addEventListener('mouseup', ()=>{ mouseDown=false; });
const keys = {};
addEventListener('keydown', (e)=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup', (e)=>keys[e.key.toLowerCase()]=false);

// UTILS
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function now(){ return performance.now(); }

// TRAILS
const trails = [];
class TrailSegment { constructor(x1,y1,x2,y2,color){ this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.color=color; } }

// ENTITIES
let entities = {};
let entityIdCounter = 1;
class Entity {
  constructor(opts){
    this.id = (entityIdCounter++).toString();
    this.name = opts.name || 'bot';
    this.x = opts.x || rand(MAP_SIZE*0.1, MAP_SIZE*0.9);
    this.y = opts.y || rand(MAP_SIZE*0.1, MAP_SIZE*0.9);
    this.dir = opts.dir || rand(0, Math.PI*2);
    this.speed = opts.speed || BOT_SPEED;
    this.radius = opts.radius || PLAYER_RADIUS;
    this.color = opts.color || this.randomColor();
    this.alive = true;
    this.lastTrailX = this.x;
    this.lastTrailY = this.y;
    this.isPlayer = !!opts.isPlayer;
    this.boost = false;
    this.score = 0;
  }
  randomColor(){
    const palette = ['#66ffea','#9ad1ff','#ffd86b','#ff9db4','#c09bff','#8bff8b'];
    return palette[Math.floor(Math.random()*palette.length)];
  }
  recordTrail(nx,ny){
    const d = dist(this.lastTrailX,this.lastTrailY,nx,ny);
    if(d>=TRAIL_MIN_DIST){
      trails.push(new TrailSegment(this.lastTrailX,this.lastTrailY,nx,ny,this.color));
      this.lastTrailX = nx; this.lastTrailY = ny;
      if(trails.length>MAX_TRAIL_SEGMENTS) trails.splice(0,trails.length-MAX_TRAIL_SEGMENTS);
    }
  }
  die(){ this.alive=false; setTimeout(()=>{ this.spawn(); },900); }
  spawn(){ this.alive=true; this.lastTrailX=this.x; this.lastTrailY=this.y; this.score=0; }
}

// PLAYER
const player = new Entity({name:'You', isPlayer:true, x:MAP_SIZE/2, y:MAP_SIZE/2, color:'#66ffea', speed:PLAYER_SPEED});
entities[player.id] = player;

// BOTS
function spawnBot(){
  const b = new Entity({name:'bot'+Math.floor(rand(1000,9999)), speed:BOT_SPEED});
  entities[b.id] = b;
  return b;
}
for(let i=0;i<BOT_COUNT_INITIAL;i++) spawnBot();
setInterval(()=>{
  if(Object.values(entities).filter(e=>!e.isPlayer).length<5) spawnBot();
}, BOT_SPAWN_INTERVAL);

// SIMULATION
function simulate(dt){
  // PLAYER
  if(player.alive){
    const worldMouseX = player.x + (mouseX - W/2);
    const worldMouseY = player.y + (mouseY - H/2);
    let dx = worldMouseX-player.x, dy = worldMouseY-player.y;
    let ang = Math.atan2(dy,dx);
    const inputVX = (keys['d']||keys['arrowright']?1:0)-(keys['a']||keys['arrowleft']?1:0);
    const inputVY = (keys['s']||keys['arrowdown']?1:0)-(keys['w']||keys['arrowup']?1:0);
    if(inputVX||inputVY) ang = Math.atan2(inputVY,inputVX);
    const diff = ((ang - player.dir + Math.PI) % (2*Math.PI)) - Math.PI;
    player.dir += diff * clamp(0.12*(dt/16.67),0,1);
    const effectiveSpeed = player.speed*(mouseDown?1.6:1.0);
    player.x += Math.cos(player.dir)*effectiveSpeed*dt/1000;
    player.y += Math.sin(player.dir)*effectiveSpeed*dt/1000;
    player.recordTrail(player.x,player.y);
  }

  // BOTS
  Object.values(entities).filter(e=>!e.isPlayer).forEach(bot=>{
    if(!bot.alive) return;
    const target = player;
    const dx = target.x - bot.x;
    const dy = target.y - bot.y;
    const ang = Math.atan2(dy,dx);
    const diff = ((ang - bot.dir + Math.PI) % (2*Math.PI)) - Math.PI;
    bot.dir += diff*0.03*(dt/16.67);
    bot.x += Math.cos(bot.dir)*bot.speed*dt/1000;
    bot.y += Math.sin(bot.dir)*bot.speed*dt/1000;
    bot.recordTrail(bot.x,bot.y);
  });

  // Collision with trails
  Object.values(entities).forEach(ent=>{
    if(!ent.alive) return;
    trails.forEach(t=>{
      if(dist(ent.x,ent.y,t.x1,t.y1)<COLLISION_DISTANCE || dist(ent.x,ent.y,t.x2,t.y2)<COLLISION_DISTANCE){
        ent.die();
      }
    });
  });

  // Update scores (longest trail)
  Object.values(entities).forEach(e=>{ e.score = trails.filter(t=>t.color===e.color).length; });
}

// DRAW
function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.save();
  // Camera centered on player
  ctx.translate(W/2 - player.x, H/2 - player.y);

  // Trails
  trails.forEach(t=>{
    ctx.strokeStyle = t.color;
    ctx.lineWidth = TRAIL_WIDTH;
    ctx.beginPath();
    ctx.moveTo(t.x1,t.y1);
    ctx.lineTo(t.x2,t.y2);
    ctx.stroke();
  });

  // Entities
  Object.values(entities).forEach(e=>{
    if(!e.alive) return;
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.radius,0,2*Math.PI);
    ctx.fill();
  });

  ctx.restore();
}

// GAME LOOP
let frames = 0, fps=0, lastFpsTs=now();
function loop(ts){
  const dt = ts-lastTs;
  lastTs=ts;
  if(!paused){
    simulate(dt);
    draw();
  }
  // FPS
  frames++;
  if(ts-lastFpsTs>1000){ fps=frames; frames=0; lastFpsTs=ts; fpsNum.textContent=fps; }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// UTIL
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
</script>
</body>
</html>
